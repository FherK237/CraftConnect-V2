"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mockEndpointBuilder = mockEndpointBuilder;
const msw_1 = require("msw");
const index_js_1 = require("../../core/index.js");
const json_js_1 = require("../../core/json.js");
const withHeaders_js_1 = require("./withHeaders.js");
const withJson_js_1 = require("./withJson.js");
class RequestBuilder {
    constructor(options) {
        this.method = "get";
        this._baseUrl = "";
        this.path = "/";
        this.predicates = [];
        this.handlerOptions = options;
    }
    baseUrl(baseUrl) {
        this._baseUrl = baseUrl;
        return this;
    }
    all(path) {
        this.method = "all";
        this.path = path;
        return this;
    }
    get(path) {
        this.method = "get";
        this.path = path;
        return this;
    }
    post(path) {
        this.method = "post";
        this.path = path;
        return this;
    }
    put(path) {
        this.method = "put";
        this.path = path;
        return this;
    }
    delete(path) {
        this.method = "delete";
        this.path = path;
        return this;
    }
    patch(path) {
        this.method = "patch";
        this.path = path;
        return this;
    }
    options(path) {
        this.method = "options";
        this.path = path;
        return this;
    }
    head(path) {
        this.method = "head";
        this.path = path;
        return this;
    }
    header(name, value) {
        this.predicates.push((resolver) => (0, withHeaders_js_1.withHeaders)({ [name]: value }, resolver));
        return this;
    }
    headers(headers) {
        this.predicates.push((resolver) => (0, withHeaders_js_1.withHeaders)(headers, resolver));
        return this;
    }
    jsonBody(body) {
        if (body === undefined) {
            throw new Error("Undefined is not valid JSON. Do not call jsonBody if you want an empty body.");
        }
        this.predicates.push((resolver) => (0, withJson_js_1.withJson)(body, resolver));
        return this;
    }
    respondWith() {
        return new ResponseBuilder(this.method, this.buildUrl(), this.predicates, this.handlerOptions);
    }
    buildUrl() {
        return index_js_1.url.join(this._baseUrl, this.path);
    }
}
class ResponseBuilder {
    constructor(method, url, requestPredicates, options) {
        this.responseStatusCode = 200;
        this.responseHeaders = {};
        this.responseBody = undefined;
        this.method = method;
        this.url = url;
        this.requestPredicates = requestPredicates;
        this.handlerOptions = options;
    }
    statusCode(code) {
        this.responseStatusCode = code;
        return this;
    }
    header(name, value) {
        this.responseHeaders[name] = value;
        return this;
    }
    headers(headers) {
        this.responseHeaders = Object.assign(Object.assign({}, this.responseHeaders), headers);
        return this;
    }
    jsonBody(body) {
        if (body === undefined) {
            throw new Error("Undefined is not valid JSON. Do not call jsonBody if you expect an empty body.");
        }
        this.responseBody = (0, json_js_1.toJson)(body);
        return this;
    }
    build() {
        var _a, _b;
        const responseResolver = () => {
            const response = new msw_1.HttpResponse(this.responseBody, {
                status: this.responseStatusCode,
                headers: this.responseHeaders,
            });
            // if no Content-Type header is set, delete the default text content type that is set
            if (Object.keys(this.responseHeaders).some((key) => key.toLowerCase() === "content-type") === false) {
                response.headers.delete("Content-Type");
            }
            return response;
        };
        const finalResolver = this.requestPredicates.reduceRight((acc, predicate) => predicate(acc), responseResolver);
        const handler = msw_1.http[this.method](this.url, finalResolver, this.handlerOptions);
        (_b = (_a = this.handlerOptions) === null || _a === void 0 ? void 0 : _a.onBuild) === null || _b === void 0 ? void 0 : _b.call(_a, handler);
        return handler;
    }
}
function mockEndpointBuilder(options) {
    return new RequestBuilder(options);
}
