"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const makeRequest_js_1 = require("../../../../../src/management/core/fetcher/makeRequest.js");
describe("Test makeRequest", () => {
    const mockPostUrl = "https://httpbin.org/post";
    const mockGetUrl = "https://httpbin.org/get";
    const mockHeaders = { "Content-Type": "application/json" };
    const mockBody = JSON.stringify({ key: "value" });
    let mockFetch;
    beforeEach(() => {
        mockFetch = jest.fn();
        mockFetch.mockResolvedValue(new Response(JSON.stringify({ test: "successful" }), { status: 200 }));
    });
    it("should handle POST request correctly", () => __awaiter(void 0, void 0, void 0, function* () {
        const response = yield (0, makeRequest_js_1.makeRequest)(mockFetch, mockPostUrl, "POST", mockHeaders, mockBody);
        const responseBody = yield response.json();
        expect(responseBody).toEqual({ test: "successful" });
        expect(mockFetch).toHaveBeenCalledTimes(1);
        const [calledUrl, calledOptions] = mockFetch.mock.calls[0];
        expect(calledUrl).toBe(mockPostUrl);
        expect(calledOptions).toEqual(expect.objectContaining({
            method: "POST",
            headers: mockHeaders,
            body: mockBody,
            credentials: undefined,
        }));
        expect(calledOptions.signal).toBeDefined();
        expect(calledOptions.signal).toBeInstanceOf(AbortSignal);
    }));
    it("should handle GET request correctly", () => __awaiter(void 0, void 0, void 0, function* () {
        const response = yield (0, makeRequest_js_1.makeRequest)(mockFetch, mockGetUrl, "GET", mockHeaders, undefined);
        const responseBody = yield response.json();
        expect(responseBody).toEqual({ test: "successful" });
        expect(mockFetch).toHaveBeenCalledTimes(1);
        const [calledUrl, calledOptions] = mockFetch.mock.calls[0];
        expect(calledUrl).toBe(mockGetUrl);
        expect(calledOptions).toEqual(expect.objectContaining({
            method: "GET",
            headers: mockHeaders,
            body: undefined,
            credentials: undefined,
        }));
        expect(calledOptions.signal).toBeDefined();
        expect(calledOptions.signal).toBeInstanceOf(AbortSignal);
    }));
});
