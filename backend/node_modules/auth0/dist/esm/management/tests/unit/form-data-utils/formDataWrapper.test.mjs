var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* eslint-disable @typescript-eslint/ban-ts-comment */
import { Readable } from "stream";
import { FormDataWrapper, newFormData } from "../../../../../src/management/core/form-data-utils/FormDataWrapper.mjs";
import { File, Blob } from "buffer";
// Helper function to serialize FormData to string for inspection
function serializeFormData(formData) {
    return __awaiter(this, void 0, void 0, function* () {
        const request = new Request("http://localhost", {
            method: "POST",
            body: formData,
        });
        const buffer = yield request.arrayBuffer();
        return new TextDecoder().decode(buffer);
    });
}
describe("FormDataWrapper", () => {
    let formData;
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        formData = new FormDataWrapper();
        yield formData.setup();
    }));
    describe("Stream handling", () => {
        it("serializes Node.js Readable stream with filename", () => __awaiter(void 0, void 0, void 0, function* () {
            const stream = Readable.from(["file content"]);
            yield formData.appendFile("file", stream, "testfile.txt");
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('Content-Disposition: form-data; name="file"');
            expect(serialized).toContain('filename="testfile.txt"');
            expect(serialized).toContain("file content");
        }));
        it("auto-detects filename from stream path property", () => __awaiter(void 0, void 0, void 0, function* () {
            const stream = Readable.from(["file content"]);
            stream.path = "/test/path/testfile.txt";
            yield formData.appendFile("file", stream);
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="testfile.txt"');
        }));
        it("handles Windows-style paths", () => __awaiter(void 0, void 0, void 0, function* () {
            const stream = Readable.from(["file content"]);
            stream.path = "C:\\test\\path\\testfile.txt";
            yield formData.appendFile("file", stream);
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="testfile.txt"');
        }));
        it("handles empty streams", () => __awaiter(void 0, void 0, void 0, function* () {
            const stream = Readable.from([]);
            yield formData.appendFile("file", stream, "empty.txt");
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="empty.txt"');
            expect(serialized).toMatch(/------formdata-undici-\w+|------WebKitFormBoundary\w+/);
        }));
        it("serializes Web ReadableStream with filename", () => __awaiter(void 0, void 0, void 0, function* () {
            const stream = new ReadableStream({
                start(controller) {
                    controller.enqueue(new TextEncoder().encode("web stream content"));
                    controller.close();
                },
            });
            yield formData.appendFile("file", stream, "webstream.txt");
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="webstream.txt"');
            expect(serialized).toContain("web stream content");
        }));
        it("handles empty Web ReadableStream", () => __awaiter(void 0, void 0, void 0, function* () {
            const stream = new ReadableStream({
                start(controller) {
                    controller.close();
                },
            });
            yield formData.appendFile("file", stream, "empty.txt");
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="empty.txt"');
            expect(serialized).toMatch(/------formdata-undici-\w+|------WebKitFormBoundary\w+/);
        }));
    });
    describe("Blob and File types", () => {
        it("serializes Blob with specified filename", () => __awaiter(void 0, void 0, void 0, function* () {
            const blob = new Blob(["file content"], { type: "text/plain" });
            yield formData.appendFile("file", blob, "testfile.txt");
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="testfile.txt"');
            expect(serialized).toContain("Content-Type: text/plain");
            expect(serialized).toContain("file content");
        }));
        it("uses default filename for Blob without explicit filename", () => __awaiter(void 0, void 0, void 0, function* () {
            const blob = new Blob(["file content"], { type: "text/plain" });
            yield formData.appendFile("file", blob);
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="blob"');
        }));
        it("preserves File object filename", () => __awaiter(void 0, void 0, void 0, function* () {
            if (typeof File !== "undefined") {
                const file = new File(["file content"], "original.txt", { type: "text/plain" });
                yield formData.appendFile("file", file);
                const serialized = yield serializeFormData(formData.getRequest().body);
                expect(serialized).toContain('filename="original.txt"');
                expect(serialized).toContain("file content");
            }
        }));
        it("allows filename override for File objects", () => __awaiter(void 0, void 0, void 0, function* () {
            if (typeof File !== "undefined") {
                const file = new File(["file content"], "original.txt", { type: "text/plain" });
                yield formData.appendFile("file", file, "override.txt");
                const serialized = yield serializeFormData(formData.getRequest().body);
                expect(serialized).toContain('filename="override.txt"');
                expect(serialized).not.toContain('filename="original.txt"');
            }
        }));
    });
    describe("Binary data types", () => {
        it("serializes ArrayBuffer with filename", () => __awaiter(void 0, void 0, void 0, function* () {
            const arrayBuffer = new ArrayBuffer(8);
            new Uint8Array(arrayBuffer).set([1, 2, 3, 4, 5, 6, 7, 8]);
            yield formData.appendFile("file", arrayBuffer, "binary.bin");
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="binary.bin"');
            expect(serialized).toMatch(/------formdata-undici-\w+|------WebKitFormBoundary\w+/);
        }));
        it("serializes Uint8Array with filename", () => __awaiter(void 0, void 0, void 0, function* () {
            const uint8Array = new Uint8Array([72, 101, 108, 108, 111]); // "Hello"
            yield formData.appendFile("file", uint8Array, "binary.bin");
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="binary.bin"');
            expect(serialized).toContain("Hello");
        }));
        it("serializes other typed arrays", () => __awaiter(void 0, void 0, void 0, function* () {
            const int16Array = new Int16Array([1000, 2000, 3000]);
            yield formData.appendFile("file", int16Array, "numbers.bin");
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="numbers.bin"');
        }));
        it("serializes Buffer data with filename", () => __awaiter(void 0, void 0, void 0, function* () {
            if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer === "function") {
                const buffer = Buffer.from("test content");
                yield formData.appendFile("file", buffer, "test.txt");
                const serialized = yield serializeFormData(formData.getRequest().body);
                expect(serialized).toContain('filename="test.txt"');
                expect(serialized).toContain("test content");
            }
        }));
    });
    describe("Text and primitive types", () => {
        it("serializes string as regular form field", () => __awaiter(void 0, void 0, void 0, function* () {
            formData.append("text", "test string");
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('name="text"');
            expect(serialized).not.toContain("filename=");
            expect(serialized).toContain("test string");
        }));
        it("serializes string as file with filename", () => __awaiter(void 0, void 0, void 0, function* () {
            yield formData.appendFile("file", "test content", "text.txt");
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="text.txt"');
            expect(serialized).toContain("test content");
        }));
        it("serializes numbers and booleans as strings", () => __awaiter(void 0, void 0, void 0, function* () {
            formData.append("number", 12345);
            formData.append("flag", true);
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain("12345");
            expect(serialized).toContain("true");
        }));
    });
    describe("Object and JSON handling", () => {
        it("serializes objects as JSON with filename", () => __awaiter(void 0, void 0, void 0, function* () {
            const obj = { test: "value", nested: { key: "data" } };
            yield formData.appendFile("data", obj, "data.json");
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="data.json"');
            expect(serialized).toContain("Content-Type: application/json");
            expect(serialized).toContain(JSON.stringify(obj));
        }));
        it("serializes arrays as JSON", () => __awaiter(void 0, void 0, void 0, function* () {
            const arr = [1, 2, 3, "test"];
            yield formData.appendFile("array", arr, "array.json");
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="array.json"');
            expect(serialized).toContain(JSON.stringify(arr));
        }));
        it("handles null and undefined values", () => __awaiter(void 0, void 0, void 0, function* () {
            formData.append("nullValue", null);
            formData.append("undefinedValue", undefined);
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain("null");
            expect(serialized).toContain("undefined");
        }));
    });
    describe("Filename extraction from objects", () => {
        it("extracts filename from object with name property", () => __awaiter(void 0, void 0, void 0, function* () {
            const namedValue = { name: "custom-name.txt", data: "content" };
            yield formData.appendFile("file", namedValue);
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="custom-name.txt"');
            expect(serialized).toContain(JSON.stringify(namedValue));
        }));
        it("extracts filename from object with path property", () => __awaiter(void 0, void 0, void 0, function* () {
            const pathedValue = { path: "/some/path/file.txt", content: "data" };
            yield formData.appendFile("file", pathedValue);
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="file.txt"');
        }));
        it("prioritizes explicit filename over object properties", () => __awaiter(void 0, void 0, void 0, function* () {
            const namedValue = { name: "original.txt", data: "content" };
            yield formData.appendFile("file", namedValue, "override.txt");
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="override.txt"');
            expect(serialized).not.toContain('filename="original.txt"');
        }));
    });
    describe("Edge cases and error handling", () => {
        it("handles empty filename gracefully", () => __awaiter(void 0, void 0, void 0, function* () {
            yield formData.appendFile("file", "content", "");
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="blob"'); // Default fallback
        }));
        it("handles large strings", () => __awaiter(void 0, void 0, void 0, function* () {
            const largeString = "x".repeat(1000);
            yield formData.appendFile("large", largeString, "large.txt");
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="large.txt"');
        }));
        it("handles unicode content and filenames", () => __awaiter(void 0, void 0, void 0, function* () {
            const unicodeContent = "Hello ä¸–ç•Œ ðŸŒ Emoji ðŸš€";
            const unicodeFilename = "Ñ„Ð°Ð¹Ð»-Ñ‚ÐµÑÑ‚-ðŸŒŸ.txt";
            yield formData.appendFile("unicode", unicodeContent, unicodeFilename);
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="' + unicodeFilename + '"');
            expect(serialized).toContain(unicodeContent);
        }));
        it("handles multiple files in single form", () => __awaiter(void 0, void 0, void 0, function* () {
            yield formData.appendFile("file1", "content1", "file1.txt");
            yield formData.appendFile("file2", "content2", "file2.txt");
            formData.append("text", "regular field");
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toContain('filename="file1.txt"');
            expect(serialized).toContain('filename="file2.txt"');
            expect(serialized).toContain('name="text"');
            expect(serialized).not.toContain('filename="text"');
        }));
    });
    describe("Request structure", () => {
        it("returns correct request structure", () => __awaiter(void 0, void 0, void 0, function* () {
            yield formData.appendFile("file", "content", "test.txt");
            const request = formData.getRequest();
            expect(request).toHaveProperty("body");
            expect(request).toHaveProperty("headers");
            expect(request).toHaveProperty("duplex");
            expect(request.body).toBeInstanceOf(FormData);
            expect(request.headers).toEqual({});
            expect(request.duplex).toBe("half");
        }));
        it("generates proper multipart boundary structure", () => __awaiter(void 0, void 0, void 0, function* () {
            yield formData.appendFile("file", "test content", "test.txt");
            formData.append("field", "value");
            const serialized = yield serializeFormData(formData.getRequest().body);
            expect(serialized).toMatch(/------formdata-undici-\w+|------WebKitFormBoundary\w+/);
            expect(serialized).toContain("Content-Disposition: form-data;");
            expect(serialized).toMatch(/------formdata-undici-\w+--|------WebKitFormBoundary\w+--/);
        }));
    });
    describe("Factory function", () => {
        it("returns FormDataWrapper instance", () => __awaiter(void 0, void 0, void 0, function* () {
            const formData = yield newFormData();
            expect(formData).toBeInstanceOf(FormDataWrapper);
        }));
        it("creates independent instances", () => __awaiter(void 0, void 0, void 0, function* () {
            const formData1 = yield newFormData();
            const formData2 = yield newFormData();
            yield formData1.setup();
            yield formData2.setup();
            formData1.append("test1", "value1");
            formData2.append("test2", "value2");
            const request1 = formData1.getRequest();
            const request2 = formData2.getRequest();
            const entries1 = Array.from(request1.body.entries());
            const entries2 = Array.from(request2.body.entries());
            expect(entries1).toHaveLength(1);
            expect(entries2).toHaveLength(1);
            expect(entries1[0][0]).toBe("test1");
            expect(entries2[0][0]).toBe("test2");
        }));
    });
});
